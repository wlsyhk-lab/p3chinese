<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>Ë™≤ÊñáÊôÆÈÄöË©±ËÆÄÈªò</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  body { font-family: "Segoe UI", Arial, sans-serif; background-color: #f5f6fa; margin: 0; padding: 20px; }
  h1 { text-align: center; margin-bottom: 25px; color: #333; }

  .audio-select-bar { text-align: center; margin-bottom: 18px; }
  .audio-select-label { font-weight: 600; margin-right: 8px; color: #333; }
  .audio-select-dropdown {
    padding: 6px 10px; border-radius: 8px; font-size: 1em; border: 1px solid #ccc;
    background-color: #fafafa; transition: border-color 0.2s, box-shadow 0.2s;
  }
  .audio-select-dropdown:focus { outline: none; border-color: #888; box-shadow: 0 0 4px rgba(0,0,0,0.15); }

  .card-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(340px, 1fr)); gap: 20px; }

  .audio-card {
    background: #fff; border-radius: 12px; box-shadow: 0 3px 10px rgba(0,0,0,0.1);
    padding: 18px; display: flex; flex-direction: column; gap: 12px;
    transition: all 0.25s ease; opacity: 1; transform: scale(1);
  }
  .audio-card:hover { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0,0,0,0.15); }

  .card-title { font-weight: bold; font-size: 1.1em; text-align: center; color: #222; }
  audio { width: 100%; }

  .segment-progress { position: relative; width: 100%; height: 6px; background-color: #eee; border-radius: 3px; overflow: hidden; margin-top: 4px; display: none; }
  .segment-progress .bar { position: absolute; height: 100%; width: 0%; background-color: #4caf50; transition: width 0.1s linear; }

  .time-label { text-align: right; font-size: 0.85em; color: #555; font-family: monospace; opacity: 0; transition: opacity 0.5s ease; }
  .time-label.visible { opacity: 1; }

  .control-group { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; justify-content: center; }
  select, button, input[type="number"], input[type="file"] { font-size: .95em; padding: 6px 10px; border-radius: 8px; border: 1px solid #ccc; background: #fafafa; }
  button { cursor: pointer; background-color: #e9e9e9; transition: background 0.2s, transform 0.1s, opacity 0.3s; }
  button:hover:not(:disabled) { background-color: #dcdcdc; }
  button:active:not(:disabled) { transform: scale(0.97); }
  button:disabled { cursor: not-allowed; opacity: 0.6; }

  .btn-rewind { background-color: #ffe6cc; border-color: #ffcc99; }
  .btn-rewind:hover:not(:disabled) { background-color: #ffd9b3; }

  .pause-list { list-style: none; padding-left: 0; margin: 6px 0; max-height: 150px; overflow-y: auto; border-top: 1px dashed #ddd; padding-top: 6px; }

  .segment-group { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; margin-top: 6px; }
  .list-title { font-weight: bold; font-size: 0.9em; color: #444; text-align: left; margin-top: 10px; cursor: pointer; user-select: none; }
  .list-title::before { content: "‚ñ∂ "; transition: transform 0.2s; }
  .list-title.expanded::before { content: "‚ñº "; }

  .collapse-content { display: none; transition: max-height 0.3s ease; overflow: hidden; }
  .collapse-content.show { display: block; }

  .toast {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    background: rgba(60, 60, 60, 0.9); color: #fff; padding: 8px 14px;
    border-radius: 6px; font-size: 0.9em; opacity: 0; transition: opacity 0.5s ease;
  }

  @media (max-width: 480px) {
    body { padding: 10px; }
    .audio-card { padding: 14px; }
    .control-group { flex-direction: column; }
    select, button, input { width: 100%; }
    .audio-select-bar { display: flex; flex-direction: column; align-items: center; gap: 6px; }
    .audio-select-dropdown { width: 90%; }
  }
</style>
</head>
<body>
<p>ËΩâÂæÄ: <a href="Â∞è‰∏âÂ≠óË©ûÊãºÈü≥ÈªòÊõ∏.html">Â∞è‰∏âÂ≠óË©ûÊãºÈü≥ÈªòÊõ∏</a></p>
<h1>Ë™≤ÊñáÊôÆÈÄöË©±ËÆÄÈªò</h1>

<div class="audio-select-bar">
  <label for="audioSelect" class="audio-select-label">Select Audio:</label>
  <select id="audioSelect" class="audio-select-dropdown">
    <option value="all">Show All</option>
  </select>
</div>

<div class="card-container" id="audioCardContainer"></div>
<div id="toast" class="toast"></div>

<script>
const audioList = [
  { name: "Â∞è‰∏âÂñÆÂÖÉ‰∏Ä„Ää‰∫îÂÄãÊñ∞Êõ∏ÂåÖ„Äã", url: "mp3LessonText/Â∞è‰∏âÂñÆÂÖÉ‰∏Ä„Ää‰∫îÂÄãÊñ∞Êõ∏ÂåÖ„ÄãÊôÆÈÄöË©±.mp3", defaultSegments: [34.1, 68.6, 98.2] }, // üëà default pause points in seconds
  { name: "Â∞è‰∏âÂñÆÂÖÉ‰∏Ä„ÄäÂ≠∏ÂØ´ÊØõÁ≠ÜÂ≠ó„Äã", url: "mp3LessonText/Â∞è‰∏âÂñÆÂÖÉ‰∏Ä„ÄäÂ≠∏ÂØ´ÊØõÁ≠ÜÂ≠ó„ÄãÊôÆÈÄöË©±.mp3", defaultSegments: [12,  28,  45.2,  68,  96]},
];

const MIN_PLAY_DURATION_IN_SEC = 2.5;
const rewindPausePositions = Array.from({ length: audioList.length }, () => 0.0);
const rewindStartPositions = Array.from({ length: audioList.length }, () => 0.0);
let hasJustBeenRewound = Array.from({ length: audioList.length }, () => false);
let collapseStates = Array.from({ length: audioList.length }, () => false);
const segmentPointsAll = Array.from({ length: audioList.length }, () => []);

const container = document.getElementById("audioCardContainer");
const audioSelect = document.getElementById("audioSelect");
const toast = document.getElementById("toast");

function showToast(message) {
  toast.textContent = message;
  toast.style.opacity = "1";
  setTimeout(() => (toast.style.opacity = "0"), 3000);
}

const cardElements = [];

function updateCardsVisibility() {
  const selectedValue = audioSelect.value;
  cardElements.forEach((card, i) => {
    const segListTitle = card.querySelector(".list-title");
    const collapseContent = card.querySelector(".collapse-content");
    if (selectedValue === "all" || parseInt(selectedValue, 10) === i) {
      card.style.display = "flex";
      requestAnimationFrame(() => {
        card.style.opacity = "1";
        card.style.transform = "scale(1)";
      });
      // Restore collapse state
      if (collapseStates[i]) {
        segListTitle.classList.add("expanded");
        collapseContent.classList.add("show");
      } else {
        segListTitle.classList.remove("expanded");
        collapseContent.classList.remove("show");
      }
    } else {
      card.style.opacity = "0";
      card.style.transform = "scale(0.98)";
      setTimeout(() => {
        if (!(audioSelect.value === "all" || parseInt(audioSelect.value, 10) === i))
          card.style.display = "none";
      }, 260);
    }
  });
}

audioList.forEach((item, index) => {
  const card = document.createElement("div");
  card.className = "audio-card";

  const title = document.createElement("div");
  title.className = "card-title";
  title.textContent = item.name;

  const audio = document.createElement("audio");
  audio.controls = true;
  const src = document.createElement("source");
  src.src = item.url;
  src.type = "audio/mpeg";
  audio.appendChild(src);

  const progressContainer = document.createElement("div");
  progressContainer.className = "segment-progress";
  const progressBar = document.createElement("div");
  progressBar.className = "bar";
  progressContainer.appendChild(progressBar);
  const timeLabel = document.createElement("div");
  timeLabel.className = "time-label";

  const speedGroup = document.createElement("div");
  speedGroup.className = "control-group";
  const speedLabel = document.createElement("label");
  speedLabel.textContent = "Speed:";
  const speedSelect = document.createElement("select");
  ["0.5","0.6","0.7","0.8","0.9","1"].forEach(sp=>{
    const opt=document.createElement("option");
    opt.value=sp; opt.textContent=`${sp}x`;
    if(sp==="0.7") opt.selected=true;
    speedSelect.appendChild(opt);
  });
  speedSelect.addEventListener("change", ()=> audio.playbackRate = parseFloat(speedSelect.value));
  speedGroup.append(speedLabel, speedSelect);

  const pauseGroup = document.createElement("div");
  pauseGroup.className = "control-group";
  const saveSegBtn = document.createElement("button");
  saveSegBtn.textContent = "üíæ Save Segment Pt";
  const rewindBtn = document.createElement("button");
  rewindBtn.textContent = "‚è™ Rewind";
  rewindBtn.className = "btn-rewind";
  const uploadBtn = document.createElement("button");
  uploadBtn.textContent = "‚¨ÜÔ∏è Upload Segments";
  const fileInput = document.createElement("input");
  fileInput.type = "file"; fileInput.accept = ".json"; fileInput.style.display = "none";
  const downloadBtn = document.createElement("button");
  downloadBtn.textContent = "‚¨áÔ∏è Download Segments";
  pauseGroup.append(saveSegBtn, uploadBtn, downloadBtn, fileInput);

  const segListTitle = document.createElement("div");
  segListTitle.className = "list-title";
  segListTitle.textContent = "Segment Pause Points:";
  segListTitle.style.display = "none";
  const collapseContent = document.createElement("div");
  collapseContent.className = "collapse-content";

  const segList = document.createElement("ul");
  segList.className = "pause-list";
  const startSelect = document.createElement("select");
  const endSelect = document.createElement("select");
  startSelect.innerHTML = "<option value=''>Start</option>";
  endSelect.innerHTML = "<option value=''>End</option>";

  const segmentPoints = segmentPointsAll[index];
  if (Array.isArray(item.defaultSegments)) {
    segmentPoints.push(...item.defaultSegments);
  }
  updateSegList();

  function updateSegList(){
    segList.innerHTML = "";
    segListTitle.style.display = segmentPoints.length ? "block" : "none";
    segmentPoints.sort((a,b)=>a-b);
    startSelect.innerHTML = "<option value=''>Start</option>";
    endSelect.innerHTML = "<option value=''>End</option>";
    segmentPoints.forEach((pt,i)=>{
      const li = document.createElement("li");
      li.textContent = `${pt.toFixed(2)}s`;
      const del = document.createElement("button");
      del.textContent = "‚ùå";
      del.addEventListener("click", ()=>{ segmentPoints.splice(i,1); updateSegList(); });
      li.appendChild(del);
      segList.appendChild(li);
      const sOpt = document.createElement("option");
      sOpt.value = pt; sOpt.textContent = `${pt.toFixed(2)}s`; startSelect.appendChild(sOpt);
      const eOpt = document.createElement("option");
      eOpt.value = pt; eOpt.textContent = `${pt.toFixed(2)}s`; endSelect.appendChild(eOpt);
    });
  }

  // --- Auto-adjust start and end selection order ---
  startSelect.addEventListener("change", () => {
    const startVal = parseFloat(startSelect.value);
    const endVal = parseFloat(endSelect.value);

    if (!isNaN(startVal) && !isNaN(endVal) && endVal <= startVal) {
      // find the next higher segment point
      const nextHigher = segmentPoints.find(pt => pt > startVal);
      if (nextHigher !== undefined) {
        endSelect.value = nextHigher;
      } else {
        // if no higher point exists, default to audio end (handled later)
        endSelect.value = "";
      }
    }
    });

  endSelect.addEventListener("change", () => {
    const startVal = parseFloat(startSelect.value);
    const endVal = parseFloat(endSelect.value);

    if (!isNaN(startVal) && !isNaN(endVal) && endVal <= startVal) {
      // find the previous lower segment point
      const reversed = [...segmentPoints].reverse();
      const prevLower = reversed.find(pt => pt < endVal);
      if (prevLower !== undefined) {
        startSelect.value = prevLower;
      } else {
        // if no lower point exists, default to audio start
        startSelect.value = "";
      }
    }
  });

  saveSegBtn.onclick = ()=> { segmentPoints.push(audio.currentTime); updateSegList(); };

  audio.addEventListener("play", ()=>{
    if (hasJustBeenRewound[index]) {
      rewindStartPositions[index] = rewindPausePositions[index];
      hasJustBeenRewound[index] = false;
    } else {
      rewindStartPositions[index] = audio.currentTime;
    }
  });

  audio.addEventListener("pause", ()=>{
    if (hasJustBeenRewound[index] && audio.currentTime >= (rewindPausePositions[index] + MIN_PLAY_DURATION_IN_SEC)) {
      rewindBtn.disabled = true;
      audio.play();
    } else {
      rewindBtn.disabled = false;
      rewindPausePositions[index] = audio.currentTime;
    }
  });

  rewindBtn.onclick = ()=>{

    if (!hasJustBeenRewound[index] && (rewindStartPositions[index] > 0 || rewindPausePositions[index] > 0)) {
      hasJustBeenRewound[index] = true;
      rewindBtn.disabled = true;
      audio.currentTime = rewindStartPositions[index];
      audio.play();
    } else {
      alert("No previous section to rewind to yet.");
    }
    if (audio.paused) {
      pauseSegBtn.textContent = "‚ñ∂Ô∏è Continue";
    } else {
      pauseSegBtn.textContent = "‚è∏ Pause";
    }

  };

  uploadBtn.onclick = ()=> fileInput.click();
  fileInput.onchange = e=>{
    const f = e.target.files[0]; if (!f) return;
    const r = new FileReader();
    r.onload = ev=>{
      try {
        const arr = JSON.parse(ev.target.result);
        if (Array.isArray(arr)) {
          segmentPoints.length = 0;
          segmentPoints.push(...arr.map(Number));
          updateSegList();
          showToast("‚úÖ Segment pause points uploaded.");
        } else showToast("‚ö†Ô∏è Invalid format.");
      } catch { showToast("‚ùå Failed to parse JSON."); }
    };
    r.readAsText(f);
  };
  downloadBtn.onclick = ()=>{
    const blob = new Blob([JSON.stringify(segmentPoints,null,2)],{type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a"); a.href = url; a.download = `${item.name}-segment-points.json`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  };

  const segmentGroup = document.createElement("div");
  segmentGroup.className = "segment-group";
  const playBtn = document.createElement("button");
  playBtn.textContent = "‚ñ∂Ô∏è Play Segment";
  const pauseSegBtn = document.createElement("button");
  pauseSegBtn.textContent = "‚è∏ Pause";

  // Toggle behavior for pause/continue
  pauseSegBtn.addEventListener("click", () => {
    if (!audio.paused) {
      audio.pause();
      pauseSegBtn.textContent = "‚ñ∂Ô∏è Continue";
    } else {
      audio.play();
      pauseSegBtn.textContent = "‚è∏ Pause";
    }
  });

  audio.addEventListener("ended", () => {
    pauseSegBtn.textContent = "‚è∏ Pause";
  });

  playBtn.addEventListener("click", async ()=>{
    if (!audio.ended && !audio.paused) audio.pause();
    let start = startSelect.value ? parseFloat(startSelect.value) : 0;
    let end = endSelect.value ? parseFloat(endSelect.value) : audio.duration;
    if (isNaN(start) || isNaN(end) || start >= end) { showToast("‚ö†Ô∏è Invalid segment."); return; }
    try {
      audio.currentTime = start;
      await new Promise(r=>setTimeout(r,100));
      await audio.play();
      progressContainer.style.display = "block";
      progressBar.style.width = "0%";
      timeLabel.textContent = `${start.toFixed(1)}s / ${end.toFixed(1)}s`;
      timeLabel.classList.add("visible");
      const duration = end - start;
      const monitor = setInterval(()=>{
        if (audio.currentTime >= end || audio.paused) {
          audio.pause(); clearInterval(monitor);
          progressContainer.style.display = "none"; progressBar.style.width = "0%";
          timeLabel.classList.remove("visible");
          setTimeout(()=> timeLabel.textContent = "", 500);
        } else {
          const p = ((audio.currentTime - start) / duration) * 100;
          progressBar.style.width = `${Math.min(p,100)}%`;
          timeLabel.textContent = `${audio.currentTime.toFixed(1)}s / ${end.toFixed(1)}s`;
        }
      }, 100);
    } catch (err) { console.error(err); showToast("‚ùå Unable to play segment."); }
  });
  segmentGroup.append(startSelect, endSelect, playBtn, pauseSegBtn, rewindBtn);

  collapseContent.append(segList);
  segListTitle.addEventListener("click", ()=>{
    segListTitle.classList.toggle("expanded");
    collapseContent.classList.toggle("show");
    collapseStates[index] = collapseContent.classList.contains("show");
  });

  card.append(title, audio, progressContainer, timeLabel, speedGroup, pauseGroup, segListTitle, collapseContent, segmentGroup);
  container.appendChild(card);
  cardElements.push(card);

  const opt = document.createElement("option");
  opt.value = index; opt.textContent = item.name;
  audioSelect.appendChild(opt);
});

if (audioList.length > 0) {
  const lastIndex = audioList.length - 1;
  audioSelect.value = String(lastIndex);
} else audioSelect.value = "all";
updateCardsVisibility();

audioSelect.addEventListener("change", updateCardsVisibility);
</script>
</body>
</html>
